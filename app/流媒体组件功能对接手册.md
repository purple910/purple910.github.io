# 流媒体组件功能对接手册

## 1.服务模式配置

### 1.1 文件清单

| 文件名            | 版本  | 描述                                                         |
| ----------------- | ----- | ------------------------------------------------------------ |
| ffmpeg            | -     | linux从apt、yum中安装，windows提供编译版本                   |
| tfswx-rtsp2webrtc | 1.0.6 | 转码服务，将RTSP协议转为webRTC协议<br />linux为：tfswx-rtsp2webrtc_架构_1.0.4<br />win为：tfswx-rtsp2webrtc_amd64-1.0.4.exe |
| config.json       | -     | tfswx-rtsp2webrtc配置文件。需要放置在jar同目录；源码工程放在工程根目录 |
| EasyDarwin        | 8.1.0 | linux为：easydarwin<br />win为：EasyDarwin.exe               |
| easydarwin.ini    | -     | EasyDarwin配置文件，不区分架构与系统                         |

### 1.2 客户端模式

> 客户端模式适用于**在线版**系统和**离线版**软件，指的是将流媒体以**插件**形式运行在用户**本地**（每个使用该系统的用户均需要安装）。其用到的主要功能是访问摄像头并**推流**、**转码**并提供本地web端预览、本地**录制**功能。客户端模式插件提供http协议的api、图形化错误提示。

#### 1.2.1 配置

> 配置文件：`application.yaml`
>
> 作为客户端，需要要修改配置如下

- 1.组件接入类型设置为`clinet 客户端`

```yaml
# 服务类型， server 是作为服务端， client 是作为本地客户端
streaming-media-module：
  type: client
```



### 1.3 服务端模式集成

> 服务端集成适用于**在线版**系统的**服务端录制、预览**功能，指的是将流媒体接入到系统后端服务中，仅随系统后端部署。
>

#### 1.3.1 集成

- 1.引入依赖

```java
implementation 'com.tfswx:tfswx-streaming-media-service:1.0.11'
```

#### 1.2.1 配置

> 配置文件：`application.yaml`
>
> 作为服务端，需要要修改配置如下

- 1.组件接入类型设置为`clinet 客户端`

```yaml
# 服务类型， server 是作为服务端， client 是作为本地客户端
streaming-media-module：
  type: server
```



## 2.推流模块对接与使用

### 2.1 配置说明 `application.yaml`

```yaml
usbCamera2Rtsp:
  # 服务启动时，存在easydarwin进程则直接关闭
  auto-close-when-server-start: true
  # rtsp流服务器地址
  easyDarwin-path:
    win: E:\RtspToWebRTC\EasyDarwin-windows-8.1.0-1901141151\EasyDarwin.exe
    linux: /home/swx/tfswxMediaStream/easydarwin
  # linux获取设备信息工具
  v4l-utils-path: v4l2-ctl
  # 随服务启动
  easyDarwin-auto-start: true
  # 【使用时必填】easyDarwin启动超时时间 ms
  easyDarwin-start-timeout: 10000
  # 推流、拉流权限控制，需要与easyDarwin.ini中配置相对应，在rtsp连接中，密码为实际密码的32位小写md5
  authorization-enable:
    # 启用rtsp鉴权
    use-it: true
    # 鉴权用户
    user: admin
    # 鉴权密码，链接中请使用32位小写MD5值
    password: admin
  # rtsp端口，linux使用8554（或其他），windows使用554（或其他）
  rtsp-port: 554
  easyDarwin-host: 192.168.7.191
  # 需要更改则请将easydarwin.ini中的对应参数修改一致
  easyDarwin-port: 10008
  push-stream:
    # 【使用时必填】 推流超时时间 ms
    start-timeout: 10000
    # 【必填】ffmpeg响应超时参数，各版本不一样，linux与旧版本win的ffmpeg为 -stimeout，windows新版本ffmpeg为 -timeout
    ffmpeg-response-timeout-option: -timeout
    # 【必填】ffmpeg响应超时时间，单位微秒
    ffmpeg-response-timeout: 5000000
    # 设备驱动设置
    devices:
      win:
        video: Doccamera
        audio: 麦克风 (Doccamera)
      linux:
        video: /dev/video0
        audio: hw:2
        audio-device-name: alsa
    # fps，旧设备适用参数，适用与设备适用的参数
    framerate: 30
    # gop_cache解决  设置I帧长度 -keyint_min 60 -g 60 -sc_threshold 0  一般设置为fps*2 2s
    keyint-min: 30
    # gop长度
    gop-length: 30
    # 0 防止自动补关键帧
    sc-threshold: 0
    # 队列长度
    thread-queue-size: 128
    # 推流协议
    rtsp-transport: tcp
    # 像素格式，旧设备适用参数
    pix-fmt: yuv420p
    # preset的参数主要调节编码速度和质量的平衡,有ultrafast、superfast、veryfast、faster、fast、medium、slow
    preset: ultrafast
    # H.264有四种画质级别,分别是baseline, extended, main, high
    vprofile: baseline
    # 调优编码参数，取值：flim，animation，grain，stillimage，psnr，ssim，fastdecode，zerolatency
    tune: grain
    video-config:
      # 视频码率上限 格式如 2048k
      max-video-bitRate: 1300k
      # 视频输入编码，新设备(linux用 h264 windows用 mjpeg)，旧设备用 mjpeg
      video-codec-in: mjpeg
      # 输出视频编码，新设备（linux用 copy windows用 h264），旧设备用 h264
      # 硬件加速支持：windows h264_qsv（待完善）
      video-codec-out: h264
      # 视频缓冲区大小 单位大写
      rtbufsize: 128M
      # 分辨率，新设备无需关注该参数。旧设备请查看对应mjpeg格式输出的分辨率，格式如 1920*1080 1280*720
      video-size: 1920*1080
    audio-config:
      # 音频缓冲区大小 单位大写
      rtbufsize: 128M
      # 音频码率上限 格式如 64k
      max-audio-bitRate: 64k
      # 音频编码，推荐aac
      audio-codec: libopus
      # 采样率
      audio-sampling-rate: 48000
      # 声道数
      audio-channel: 1
      # -2为使用ffmpeg自带的aac库，audio-codec为AAC时生效
      aac-strict: -2
    # 滤镜（用于字幕）
    subtitle:
      # 启用
      enable: true
      # 字母内容
      drawtext: expansion=strftime:x=w-tw:fontcolor=red:fontsize=30:text='%Y/%m/%d %H\:%M\:%S'
```

### 2.2 推流相关接口使用

#### 1.开始推流

**接口地址**:`/camera2rtsp/startPushStream`

**请求方式**:`POST`

**请求数据类型**:`application/json`

**接口描述**: 开始推流任务，理论上，同一客户端（用户）仅可进行一次推流。推流是将本地的USB摄像头设备以RTSP流形式推出，以供预览、本地和远端录制。使用推流接口前，请确保设备已插入并在application.yaml中配置对应设备的参数。

**请求示例**:


```json
{
  "audioDriverName": "",
  "enableAudio": true,
  "enableVideo": true,
  "streamName": "",
  "videoDriverName": "",
  "videoSize": "传入1920*1080类型分辨率"
}
```

**请求参数**:


| 参数名称                    | 参数说明         | 请求类型 | 是否必须 | 数据类型                      |
| --------------------------- | ---------------- | -------- | -------- | ----------------------------- |
| requestData                 | requestData      | body     | true     | ClientPushStreamStartInputDTO |
| &emsp;&emsp;audioDriverName | 音频驱动（名称） |          | false    | string                        |
| &emsp;&emsp;enableAudio     | 启用音频         |          | true     | boolean                       |
| &emsp;&emsp;enableVideo     | 启用视频         |          | true     | boolean                       |
| &emsp;&emsp;streamName      | 流名称、路径     |          | true     | string                        |
| &emsp;&emsp;videoDriverName | 视频驱动（名称） |          | false    | string                        |
| videoSize                   | 分辨率           |          | false    | string                        |

**响应示例**:

- 成功，code为0，data返回rtsp流地址

```json
{"code":0,"message":"成功","data":"rtsp://admin:21232f297a57a5a743894a0e4a801fc3@192.168.7.191:554/test"}
```

- 失败，code为-1，message返回失败原因

```json
{
  "code": -1,
  "message": "usbCamera2rtspException：摄像头、麦克风设备脱机，可能设置了不支持的分辨率：video=doccamera: I/O error\r\n",
  "data": null
}
```

#### 2.停止推流


**接口地址**:`/camera2rtsp/stopPushStream`


**请求方式**:`POST`

**请求数据类型**:`application/json`

**接口描述**: 停止正在进行的推流任务，释放设备I/O。为确保录制、预览功能正确结束，请先确保该RTSP流无其他设备访问后再停止推流。

**请求示例**:


```json
{
  "streamName": ""
}
```


**请求参数**:


| 参数名称               | 参数说明     | 请求类型 | 是否必须 | 数据类型                     |
| ---------------------- | ------------ | -------- | -------- | ---------------------------- |
| requestData            | requestData  | body     | true     | ClientPushStreamStopInputDTO | ClientPushStreamStopInputDTO |
| &emsp;&emsp;streamName | 流名称、路径 |          | true     | string                       |

**响应示例**:

- 成功，code为0，data返回“关闭成功”

```json
{"code":0,"message":"成功","data":"关闭成功"}
```

- 失败，code为-1，message返回失败原因

```json
{
  "code": -1,
  "message": "usbCamera2rtspException：未找到该进程",
  "data": null
}
```

## 3.预览模块对接与使用

### 3.1 配置说明

```yaml
rtsp2webRTC:
  # 随服务启动
  auto-start: true
  # 服务启动时，存在tfswx-rtsp2webrtc进程则直接关闭
  auto-close-when-server-start: true
  # 是否意外推出后自动拉起服务
  auto-restart: true
  #【使用时必填】 转码服务启动超时时间 ms
  start-timeout: 5000
  # 是否启用
  use-it: true
  # 【启用后必填】rtsp2webRTC服务配置，端口必须与config.json中配置的相同
  host: http://127.0.0.1
  port: 9323
  # windows启动命令和配置文件路径配置
  win:
    # 【启用后必填】启动文件/命令路径
    cmd-path: E:\\RtspToWebRTC\\RTSPtoWebRTC-master\\bin\\tfswx-rtsp2webrtc_amd64-1.0.6.exe
    # 【启用后必填】配置文件路径，限定该文件与本服务在同级，本项目不允许修改
    config-path: ./config.json
  linux:
    cmd-path: ./tfswx-rtsp2webrtc_aarch64-1.0.6
    config-path: ./config.json
```

### 3.2 预览相关接口使用

> 由于预览相关接口经过两层服务的封装，请注意接口的返回值封装！
>
> 注意config.json文件位置需要与jar同目录，源码启动时需要放在工程根目录中。

#### 1.添加RTSP源并开始转码

**接口地址**:`/rtsp2webRTC/addRtspSource`

**请求方式**:`POST`

**请求数据类型**:`application/json`

**接口描述**:添加一个RTSP源并对该RTSP源进行解码。


**请求示例**:


```javascript
{
  "disableAudio": true,
  "disableRepeatUrl": true,
  "onDemand": true,
  "key": "",
  "url": ""
}
```

**请求参数**:


| 参数名称                     | 参数说明            | 请求类型 | 是否必须 | 数据类型             | 说明                                                         |
| ---------------------------- | ------------------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |
| requestData                  | requestData         | body     | true     | ClientRtcAddInputDTO |                                                              |
| &emsp;&emsp;disableAudio     | 禁用音频            |          | true     | boolean              |                                                              |
| &emsp;&emsp;disableRepeatUrl | 禁止同一URL重复解码 |          | true     | boolean              | 传入true时，若传入的url已存在，则返回已存在的key，不重复进行解码。反之则重复进行解码。 |
| &emsp;&emsp;key              | 指定转码任务的key   |          | false    | string               | 可传入指定的key，不传入则随机生成。key为后续接口对解码的流的访问凭证。 |
| &emsp;&emsp;url              | RTSP地址            |          | true     | string               | 完整的RTSP地址，需要鉴权则需要在其中填入用户、密码。         |

**响应示例**:

- 成功，code为0，data中为返回的信息。
  - data.data.key为解码的key，后续使用该key进行访问解码的流。
  - data.data.code为添加状态，true是添加成功；false添加失败，失败时message会返回错误信息。

```json
{
  "code": 0,
  "message": "成功",
  "data": {
    "data": {
      "code": true,
      "message": "添加成功",
      "key": "450422F6782D4483AAFFD1B3503A09CB"
    }
  }
}
```

- 失败，code为-1，message为错误信息

```json
{
  "code": -1,
  "message": "错误信息",
  "data": null
}
```



#### 2.获取媒体信息

**接口地址**:`/rtsp2webRTC/codec`

**请求方式**:`GET`

**接口描述**:获取已添加并正在解码的RTSP流的流媒体信息。

**请求参数**:


| 参数名称 | 参数说明 | 请求类型 | 是否必须 | 数据类型 | 说明                             |
| -------- | -------- | -------- | -------- | -------- | -------------------------------- |
| key      | key      |          | true     | string   | 该key为上述添加RTSP源后返回的key |

**访问示例**：

```text
/rtsp2webRTC/codec?key=xxxxxxxxxxxx
```

**响应示例**:

- 成功，code为0，data中为返回的信息。
  - data中包含：`Type: key不存在`，则表示传入的key不存在，可能为添加的RTSP流不正确或已无客户端预览而被删除。
  - data中包含：`Type: video`或`Type: audio`则存在对应的音、视频轨道。
  - data为空则说明该RTSP流不存在媒体信息。

```text
{"code":0,"message":"成功","data":"[{\"Type\":\"video\"}]"}
```

- 失败，code为-1，message为错误信息

```json
{
  "code": -1,
  "message": "错误信息",
  "data": null
}
```

#### 3.添加并获取媒体信息（相当于一步完成1、2中的两个接口）

**接口地址**:`/rtsp2webRTC/addWithCodec`

**请求方式**:`POST`

**请求数据类型**:`application/json`

**接口描述**:添加一个RTSP源并对该RTSP源进行解码。


**请求示例**:


```javascript
{
  "disableAudio": true,
  "disableRepeatUrl": true,
  "onDemand": true,
  "key": "",
  "url": ""
}
```

**请求参数**:


| 参数名称                     | 参数说明            | 请求类型 | 是否必须 | 数据类型             | 说明                                                         |
| ---------------------------- | ------------------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |
| requestData                  | requestData         | body     | true     | ClientRtcAddInputDTO |                                                              |
| &emsp;&emsp;disableAudio     | 禁用音频            |          | true     | boolean              |                                                              |
| &emsp;&emsp;disableRepeatUrl | 禁止同一URL重复解码 |          | true     | boolean              | 传入true时，若传入的url已存在，则返回已存在的key，不重复进行解码。反之则重复进行解码。 |
| &emsp;&emsp;key              | 指定转码任务的key   |          | false    | string               | 可传入指定的key，不传入则随机生成。key为后续接口对解码的流的访问凭证。 |
| &emsp;&emsp;url              | RTSP地址            |          | true     | string               | 完整的RTSP地址，需要鉴权则需要在其中填入用户、密码。         |

**响应示例**:

- 成功，code为0，data中为返回的信息。
  - data.key为解码的key，后续使用该key进行访问解码的流。
  - data.typeList为音视频媒体轨道信息，type字段包含video则说明rtsp流含有视频轨道，type含有audio同理。

```json
{
  "code": 0,
  "message": "成功",
  "data": {
    "key": "A78606090FD249E7828E371AF6C536BA",
    "typeList": [
      {
        "type": "video"，
        "type": "audio"
      }
    ]
  }
}
```

- 失败，code为-1，message为错误信息

```json
{
  "code": -1,
  "message": "错误信息",
  "data": null
}
```

#### 4.点对点连接


**接口地址**:`/rtsp2webRTC/receiver`


**请求方式**:`POST`

**请求数据类型**:`application/json`


**响应数据类型**:`*/*`

**接口描述**: 用于与转码服务建立点对点连接。


**请求示例**:


```javascript
{
  "key": "",
  "sdp": ""
}
```


**请求参数**:


| 参数名称        | 参数说明               | 请求类型 | 是否必须 | 数据类型                  | 说明 |
| --------------- | ---------------------- | -------- | -------- | ------------------------- | ---- |
| requestData     | requestData            | body     | true     | ClientRtcReceiverInputDTO |      |
| &emsp;&emsp;key | 预览的key,1或3中返回的 |          | true     | string                    |      |
| &emsp;&emsp;sdp | sdp协商信息            |          | true     | string                    |      |

**响应示例**:

-  成功，code为0，data为返回的sdp的answer信息。若data为空，则表示建立连接失败。

```json
{"code":0,"message":"成功","data":"sdp信息，很长的字符串"}
```

- 失败，code为-1，message为错误信息

```json
{
  "code": -1,
  "message": "错误信息",
  "data": null
}
```

#### 5.停止转码并删除该RTSP流信息


**接口地址**:`/rtsp2webRTC/stopAndDeleteRtspSource`


**请求方式**:`POST`


**请求数据类型**:`application/json`

**响应数据类型**:`*/*`

**接口描述**: 将1或3添加到转码服务的RTSP流停止转码并删除


**请求参数**:


| 参数名称 | 参数说明               | 请求类型 | 是否必须 | 数据类型 | 说明 |
| -------- | ---------------------- | -------- | -------- | -------- | ---- |
| key      | 预览的key,1或3中返回的 | body     | true     | String   |      |

**响应示例**:

- 成功，data.data.code返回true，data.data.message返回删除成功。

```text
{
  "code": 0,
  "message": "成功",
  "data": {
    "data": {
      "code": true,
      "message": "删除成功",
      "key": "传入的key值"
    }
  }
}
```

- 失败，data.data.code返回false，data.data.message返回错误信息。

```
{
  "code": 0,
  "message": "成功",
  "data": {
    "data": {
      "code": false,
      "message": "错误信息",
      "key": "传入的key值"
    }
  }
}
```



#### 6.获取所有已添加的RTSP流信息


**接口地址**:`/rtsp2webRTC/rtspSourceList`


**请求方式**:`GET`


**请求数据类型**:`application/x-www-form-urlencoded`


**响应数据类型**:`*/*`

**接口描述**:获取已添加的转码列表

**请求参数**:无

**响应示例**:

- 成功，data.data.code返回true，data.data.message返回RTSP流列表，data.data.message返回为null时代表没有正在转码的RTSP流信息

```text
{
  "code": 0,
  "message": "成功",
  "data": {
    "data": {
      "code": true,
      "message": [
        {
          "key": "643E304B648C4DDFA451F18EF027CF17",
          "url": "rtsp://admin:21232f297a57a5a743894a0e4a801fc3@192.168.7.191:554/test",
          "onDemand": true,
          "disableAudio": true,
          "disableRepeatUrl": true
        }
      ],
      "key": ""
    }
  }
}
```

#### 7.获取正在转码的RTSP流预览的客户端数量信息


**接口地址**:`/rtsp2webRTC/watchingList`


**请求方式**:`GET`


**请求数据类型**:`application/x-www-form-urlencoded`


**响应数据类型**:`*/*`

**接口描述**:获取正在转码的RTSP流预览的客户端数量信息

**请求参数**:无

**响应示例**:

- 成功，data.data.code返回true，data.data.message返回列表，其中键为RTSP对应的转码的KEY，值为客户端数量

```text
{
  "code": 0,
  "message": "成功",
  "data": {
    "data": {
      "code": true,
      "message": {
        "D59BBBF409694939BCA97A237AEE204B": 1
      },
      "key": ""
    }
  }
}
```

#### 8. 其他不常用、定制化接口请启动后查看swagger文档



## 4.录制模块对接与使用

### 4.1 配置说明

```yaml
rtsp2mp4:
  # 服务启动时，存在ffmpeg进程则直接关闭
  auto-close-when-server-start: true
  # 文件相关
  file:
    linux:
      # 【必填】录制mp4存储位置
      base-path: /data/video
      # 【必填】ffmpeg组件命令位置
      ffmpeg-path: ffmpeg
    win:
      base-path: E:\\RtspToWebRTC\\video
      ffmpeg-path: E:\RtspToWebRTC\ffmpeg-4.1.1-win64-static\bin\\ffmpeg.exe
  # 录制相关参数
  record:
    start-timeout: 10000
    # 【暂未启用，请使用接口传输该值】指定传输协议，理论上使用tcp，但音视频盒子使用该参数会出现Unknown Error问题，所以开放为配置项
    rtsp-transport: tcp
    # 【必填】录制视频配置
    video-config:
      # true为使用rtsp源参数直接录制，false为使用下列参数录制。推荐设置为true 无特殊请求请勿更改
      default: false
      # 视频宽 必须为偶数
      video-width: 1920
      # 视频高 必须为偶数
      video-height: 1080
      # 录制分辨率 格式 1920:1080
      scale:
      # 视频码率上限 格式如 2048k
      max-video-bitRate: 1300k
      # 视频编码
      video-codec: copy
    # 【必填】录制音频配置，注，将含G711.A（pcma）音频编码的rtsp流录制为mp4需要开启此项转码，且建议转为aac编码
    audio-config:
      # true为使用rtsp源参数直接录制，false为使用下列参数录制。推荐设置为true
      default: false
      # 音频码率上限 格式如 64k
      max-audio-bitRate: 64k
      # 音频编码，推荐aac
      auido-codec: aac
      # -2为使用ffmpeg自带的aac库
      aac-strict: -2
    # 【必填】默认录制格式
    default-format: mp4
    # 【必填】ffmpeg响应超时参数，各版本不一样，linux与旧版本win的ffmpeg为 -stimeout，windows新版本ffmpeg为 -timeout
    ffmpeg-response-timeout-option: -timeout
    # 【必填】ffmpeg响应超时时间，单位微秒
    ffmpeg-response-timeout: 5000000
    # 【必填】分片录制
    segment:
      # 是否开启分片录制
      open: false
      # 分片录制时间 单位s
      segment-time: 60
    # 【必填】文件存在校验，为false且视频文件存在则会为文件名加上时间戳，为true时，文件存在则开始录制时报错
    file-exits-check: 1
    # 【必填】失败重试录制
    retry-with-error:
      # 是否开启
      open: true
      # 重试次数
      retry-times: 3
  # 【必填】心跳（脱机检查）配置
  heartBeat:
    # 是否进行心跳策略，false则不进行脱机检查
    check: false
    # 心跳有效时长，ms
    interval-time: 60000
    # 心跳检查定时器
    cron: 0 * * * * ?
```

### 4.2客户端模式接口

#### 1.开始录制


**接口地址**:`/rtsp2mp4/start`


**请求方式**:`POST`


**请求数据类型**:`application/json`


**响应数据类型**:`*/*`

**接口描述**:开始录制


**请求示例**:


```javascript
{
  "basePath": "",
  "fileName": "",
  "rtspSource": ""
}
```


**请求参数**:


| 参数名称       | 参数说明                                         | 请求类型 | 是否必须 | 数据类型                  | schema                    |
| -------------- | ------------------------------------------------ | -------- | -------- | ------------------------- | ------------------------- |
| requestData    | requestData                                      | body     | true     | ClientRecordStartInputDTO | ClientRecordStartInputDTO |
| &emsp;basePath | msp; \| 文件存储路径，默认使用配置文件配置的地址 |          | false    | String                    |                           |
| fileName       | 文件名，不含格式后缀                             |          | true     | String                    |                           |
| rtspSource     | rtsp源地址                                       |          | true     | String                    |                           |

**响应示例**:

- 成功，code返回0，data返回完整的录制文件名（带后缀）

```json
{
  "code": 0,
  "message": "成功",
  "data": "old_1080.mp4"
}
```

- 失败，code返回-1，message返回错误信息

```json
{
  "code": -1,
  "message": "rtsp2mp4Exception：录制启动异常",
  "data": null
}
```

#### 2.结束录制


**接口地址**:`/rtsp2mp4/stop`


**请求方式**:`POST`


**请求数据类型**:`application/json`


**响应数据类型**:`*/*`

**接口描述**:结束录制，并重命名


**请求示例**:


```javascript
{
  "basePath": "",
  "fileName": "",
  "newFileName": "",
  "waitFileFree": true
}
```


**请求参数**:


| 参数名称                 | 参数说明                                                     | 请求类型 | 是否必须 | 数据类型                 | schema                   |
| ------------------------ | ------------------------------------------------------------ | -------- | -------- | ------------------------ | ------------------------ |
| requestData              | requestData                                                  | body     | true     | ClientRecordStopInputDTO | ClientRecordStopInputDTO |
| &emsp;&emsp;basePath     | 文件存储路径; 开始录制传了该参数，且waitFileFree=true时，这里必传与开始录制传入相同的参数 |          | false    | string                   |                          |
| &emsp;&emsp;fileName     | 文件名全名                                                   |          | true     | string                   |                          |
| &emsp;&emsp;newFileName  | 重命名名称，带后缀。需要waitFileFree=true才生效              |          | false    | string                   |                          |
| &emsp;&emsp;waitFileFree | 等待文件空闲，传入true则该请求会在录制文件被ffmpeg释放后再返回 |          | true     | boolean                  |                          |

**响应示例**:

- 成功,code返回0，data返回”已结束录制，重命名成功“；若data返回”已结束录制，但重命名失败“表示重命名失败，可能是录制文件被其他进程占用。

```json
# waitFileFree为true
{
  "code": 0,
  "message": "成功",
  "data": "已结束录制，重命名成功"
}
# waitFileFree为false
{
  "code": 0,
  "message": "成功",
  "data": "已结束录制，未等待录制成果文件释放"
}
```

- 失败

```json
{
  "code": -1,
  "message": "rtsp2mp4Exception：未找到该录制进程",
  "data": null
}
```

#### 3.获取录制任务心跳


**接口地址**:`/rtsp2mp4/heartBeat`


**请求方式**:`GET`


**请求数据类型**:`application/x-www-form-urlencoded`


**响应数据类型**:`*/*`

**接口描述**:获取录制的心跳，心跳中包含了录制进度信息


**请求参数**:


| 参数名称 | 参数说明                                     | 请求类型 | 是否必须 | 数据类型 | schema |
| -------- | -------------------------------------------- | -------- | -------- | -------- | ------ |
| fileName | 文件全名，带后缀，为开始录制接口返回的文件名 | query    | true     | string   |        |

**响应示例**:

- 成功，data返回进度信息，其中frame为录制总帧数，fps为录制帧率，q为质量系数，size为录制大小，time为录制时间，birate为录制码率，speed为编码速率。

```json
{
  "code": 0,
  "message": "成功",
  "data": "frame=  480 fps= 32 q=-1.0 size=    2048kB time=00:00:16.03 bitrate=1046.6kbits/s speed=1.06x    \r"
}
```

- 失败

```json
{
  "code": -1,
  "message": "rtsp2mp4Exception：录制任务不存在",
  "data": null
}
```

### 4.3 服务端接入远端录制（或是重写接口）参考代码-后端

```java
package com.tfswx.rtsp2mp4.api;

import com.tfswx.rtsp2mp4.dto.ClientRecordStartInputDTO;
import com.tfswx.rtsp2mp4.dto.ClientRecordStopInputDTO;
import com.tfswx.rtsp2mp4.service.RtspToMp4ByFfmpegService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

/**
 * @author 谭凯
 * @Description: RTSP流转Mp4 API
 * @Date: 2022/8/1  10:59
 */
@RestController
@Api(tags = "录制")
@RequestMapping("/rtsp2mp4")
@ConditionalOnProperty(name = "streaming-media-module-type", havingValue = "client")
public class RtspToMP4Controller {

    @Resource
    private RtspToMp4ByFfmpegService rtspToMp4ByFfmpegService;

    @ApiOperation(value = "开始录制任务")
    @PostMapping(value = "/start")
    public String start(@RequestBody @Validated ClientRecordStartInputDTO requestData) {
        return rtspToMp4ByFfmpegService.start(requestData);
    }

    @ApiOperation(value = "结束录制任务")
    @PostMapping(value = "/stop")
    public String stop(@RequestBody @Validated ClientRecordStopInputDTO requestData) {
        return rtspToMp4ByFfmpegService.stop(requestData.getFileName());
    }

    @ApiOperation(value = "录制任务心跳")
    @GetMapping(value = "/heartBeat")
    public String heartBeat(@RequestParam("fileName") String requestData) {
        return rtspToMp4ByFfmpegService.heartBeat(requestData);
    }

    @ApiOperation(value = "获取录制任务进度信息")
    @GetMapping(value = "/getRecordMessage")
    public String getRecordMessage(@RequestParam("fileName") String requestData) {
        return rtspToMp4ByFfmpegService.getRecordMessage(requestData);
    }

}
```



## 5.预览前端使用示例

### 5.1 前端接口调用

> 若组件是以插件形式运行在浏览器端的本地，则页面请求需要直接请求到使用网页的本地，**需配置127.0.0.1的代理或baseUrl**。

### 5.2 预览集成代码示例（谷歌内核）

- index.html引入静态js文件，以适配低于69内核的浏览器。

```html
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
```

- 预览webRTC链接示例

```js
	/**
     * 获取媒体流轨道信息
     */
    async getCodecInfo() {
      if (!this.key || this.key == "") {
        this.$message("请输入预览的key");
      }
      await this.$tf_get("/rtsp2webRTC/codec?key=" + this.key).then((res) => {
        if (res.data.indexOf("key不存在") != -1) {
          this.$message("key不存在");
          return;
        }
        if (res.data.length == 0) {
          this.$message("无轨道信息");
          return;
        }
        if (res.data.indexOf("audio") != -1) {
          this.isOfferToReceiveAudio = true;
        }
        if (res.data.indexOf("video") != -1) {
          this.isOfferToReceiveVideo = true;
        }
      });
    },

    /**
     * 关闭rtc连接
     */
    closeConnection() {
      this.pc.close();
    },

    /**
     * 建立webRTC连接
     */
    async startWebRTCInstance() {
      if (!this.key || this.key == "") {
        this.$message("请先输入key");
        return;
      }
      this.stream = new MediaStream();
      this.pc = new RTCPeerConnection({});
      await this.getCodecInfo();
      this.pc.onnegotiationneeded = this.handleNegotiationNeededEvent();
      let _this = this;
      this.pc.ontrack = function (event) {
        _this.stream.addTrack(event.track);
        videoElem.srcObject = _this.stream;
      };
      /**
       * 点对点连接状态改变
       */
      this.pc.oniceconnectionstatechange = (e) => {
        console.log(this.pc.iceConnectionState);
        if (e == "checking") {
          this.$message.success("检查连接");
        } else if (e == "connected") {
          // 连接
          this.$message.success("已连接");
        } else if (e == "disconnected") {
          this.$message("断开连接");
          // 清理本次的pc
          this.pc.close();
        }
      };
    },

    async handleNegotiationNeededEvent() {
      let offer = await this.pc.createOffer({
        offerToReceiveAudio: this.isOfferToReceiveAudio,
        offerToReceiveVideo: this.isOfferToReceiveVideo,
      });
      await this.pc.setLocalDescription(offer);
      this.getRemoteSdp();
    },

     /**
     * 信令交换
     */
    getRemoteSdp() {
      this.$tf_post("/rtsp2webRTC/receiver", {
        key: this.key,
        data: btoa(this.pc.localDescription.sdp),
      }).then((r) => {
        console.log(r);
        try {
          this.pc.setRemoteDescription(
            new RTCSessionDescription({
              type: "answer",
              sdp: atob(r.data),
            })
          );
        } catch (e) {
          console.warn(e);
        }
      });
    },
```









